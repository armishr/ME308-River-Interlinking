# -*- coding: utf-8 -*-
"""Interlinking of rivers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/148rKbFEFEq6uQC8NfXCf_ZU_20JGjwlT

# Interlinking of Rivers

#Getting the map into discrete grid points
The map of India will be divided in grid points with $n$ rows and $m$ columns. Each grid point will have a number of parameter values relevant to the LPP formulation related geographically to that position.
"""

#importing basic libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.image as img
#for uploading images
from google.colab import files
from IPython.display import Image
import ee
import cv2
import csv
from google.colab.patches import cv2_imshow
from matplotlib.pyplot import figure
from scipy.interpolate import Rbf

!pip install gurobipy

import gurobipy as gp
from gurobipy import *

# Create an environment with your WLS license
# params = {
# "WLSACCESSID": "3248a1bc-8656-4ee5-b559-18a919908548",
# "WLSSECRET": "73adeb64-f633-447c-a9e9-d6d95afeff34",
# "LICENSEID": 946447,
# }
# env = gp.Env(params=params)

try:

    # Setup the Gurobi environment with the WLS license
    e = gp.Env(empty=True)

    wlsaccessID = os.getenv('GRB_WLSACCESSID','undefined')
    e.setParam('WLSACCESSID', "3248a1bc-8656-4ee5-b559-18a919908548")

    licenseID = os.getenv('GRB_LICENSEID', '0')
    e.setParam('LICENSEID', 946447)

    wlsSecrets = os.getenv('GRB_WLSSECRET','undefined')
    e.setParam('WLSSECRET', "73adeb64-f633-447c-a9e9-d6d95afeff34")

    e.setParam('CSCLIENTLOG', int(3))

    e.start()

except gp.GurobiError as e:
    print('Error code ' + str(e.errno) + ": " + str(e))

except AttributeError:
    print('Encountered an attribute error')

#?

!chmod 755 opt
!chmod 755 grbgetkey
!/content/opt/gurobi/grbgetkey 3248a1bc-8656-4ee5-b559-18a919908548

# uploaded = files.upload()

map1 = cv2.imread("simplified map.png")  
cv2_imshow(map1)

figure(figsize=(20, 20), dpi=80)
map2 = cv2.cvtColor(map1, cv2.COLOR_RGB2BGR)
plt.imshow(map2)

n = 25
m = 36
# this is our grid resolution

from scipy.stats import multivariate_normal

# Define the mean and covariance matrix for the 2D normal distribution
mean = [-2, -3]
cov = [[1, 0], [0, 1]]

# Create a grid of coordinates using np.meshgrid()
x_0, y_0 = np.meshgrid(np.linspace(-5, 5, m), np.linspace(-5, 5, n))

# Evaluate the probability density function for each coordinate pair
pos = np.empty(x_0.shape + (2,))
pos[:, :, 0] = x_0
pos[:, :, 1] = y_0
pdf = multivariate_normal(mean, cov).pdf(pos)

# Create a heatmap of the PDF values
plt.imshow(pdf.transpose(), cmap='jet', interpolation='nearest', origin='lower')

# Show the plot
plt.colorbar()
plt.show()

b = map2.shape[0]
l = map2.shape[1]
x_points = np.linspace(0,l,n)
y_points = np.linspace(0,b,m)

fig, ax = plt.subplots(1, 1, figsize = (20, 20),dpi = 70)
ax.set_xticks(x_points)
ax.set_yticks(y_points)
ax.imshow(map2)
ax.grid(color='b', linestyle='-', linewidth=2)

# Create an environment with your WLS license
params = {
"WLSACCESSID": '3248a1bc-8656-4ee5-b559-18a919908548',
"WLSSECRET": '73adeb64-f633-447c-a9e9-d6d95afeff34',
"LICENSEID": 946447,
}
env = gp.Env(params=params)

# Create the model within the Gurobi environment
f = gp.Model(env=env)

# Creating a new model
#f = gp.Model("test")

"""Boundary is the corner case but considering the map we've chosen, it is unlikely for the link to be along the edges. Hence, that case can be ignored"""

# Create variables
x = {}
for i in range(0,m):
  x[i] = f.addVars(n,vtype = GRB.BINARY)

a = 1 #Flow factor which changes on addition of reservoirs

# testing
x[22][10]

# parameters

#np.random.seed(3)
#drought = np.random.uniform(10,100,(m,n))
# with open('arr1.csv', newline='') as csvfile:
#     drought = list(csv.reader(csvfile))
drought = pd.read_csv('watertable.csv', header = None ).values
population = pd.read_csv('population.csv', header = None).values
elevation = population = pd.read_csv('elevation.csv', header = None).values
drought = drought.transpose()
population = population.transpose()
elevation = elevation.transpose()
 #arr1 has the population data of size 25x36

plt.imshow(elevation, cmap='jet', interpolation='nearest', origin='lower')
plt.colorbar()
plt.show()

plt.imshow(population/drought, cmap='jet', interpolation='nearest', origin='lower')
plt.colorbar()
plt.show()

# constraints

f.addConstr(x[2*m//36][14*n//25]+x[33*m//36][10*n//25]+x[13*m//36][13*n//25]+x[17*m//36][13*n//25]+x[21*m//36][12*n//25]+x[24*m//36][9*n//25]+x[29*m//36][9*n//25] >= 7) #fixing some points
# These include start, end and the dam points
f.addConstr(x[2*m//36][14*n//25]+x[33*m//36][10*n//25]+x[13*m//36][13*n//25]+x[17*m//36][13*n//25]+x[21*m//36][12*n//25]+x[24*m//36][9*n//25]+x[29*m//36][9*n//25] <= 7)

## NOTE: dams, start and end points have been hardcoded according to 
sumX = 0
for i in range(0,m):
  for j in range(0,n):
    sumX = sumX +x[i][j]

# Cost function. For now it is just the number of grid tiles
f.addConstr(sumX >= 35*(n*m/(25*36)))
f.addConstr(sumX <= 100*(n*m/(25*36)))

# Range has been adjused to not let i-1, j-1 terms overflow
for i in range(1,m-1):
  for j in range(1,n-1):
    if((i==(2*m//36) and j==(14*n//25)) or (i==(33*m//36) and j==(10*n//25))):
      f.addConstr(x[i+1][j]+x[i-1][j]+x[i][j+1]+x[i][j-1] <= 4 - 3*x[i][j])
      f.addConstr(x[i+1][j]+x[i-1][j]+x[i][j+1]+x[i][j-1] >= x[i][j])
    else:
      f.addConstr(x[i+1][j]+x[i-1][j]+x[i][j+1]+x[i][j-1] <= 4 - 2*x[i][j])
      f.addConstr(x[i+1][j]+x[i-1][j]+x[i][j+1]+x[i][j-1] >= 2*x[i][j])

# dealing with edges
for j in range(0,n):
  f.addConstr(x[0][j] >= 0)
  f.addConstr(x[0][j] <= 0)

for i in range(0,m):
  f.addConstr(x[i][0] >= 0)
  f.addConstr(x[i][0] <= 0)

for j in range(0,n):
  f.addConstr(x[m-1][j] >= 0)
  f.addConstr(x[m-1][j] <= 0)

for i in range(0,m):
  f.addConstr(x[i][n-1] >= 0)
  f.addConstr(x[i][n-1] <= 0)

#dealing with closed loops
for i in range(0,m-1):
  for j in range(0,n-1):
    f.addConstr(x[i][j]+x[i+1][j]+x[i+1][j+1]+x[i][j+1] <=3)

cost_matrix = population*(1/drought)
n_factor = np.std(cost_matrix)
n_matrix = cost_matrix/n_factor
b = 85
h_factor = np.std(elevation)/b

n_factor

# objective function
sumT = 0
#sumT_2 = 0
for i in range(0,m):
  for j in range(0,n):
    #sumT = sumT + a*x[i][j]*population[i,j]*(1/drought[i,j])*(1/elevation[i,j])
    #sumT = sumT + a*x[i][j]*population[i,j]*(1/drought[i,j])
    #sumT_2 = sumT_2 + a*population[i,j]*x[i][j]
    sumT = sumT + (cost_matrix[i][j] - elevation[i][j]/h_factor)*x[i][j]

#sumT = 40*sumT - sumX*25

f.setObjective(sumT, GRB.MAXIMIZE)

f.optimize()

sumX.getValue()

output = np.random.rand(m,n)

for i in range(0,m):
  for j in range(0,n):
    output[i,j] = x[i][j].x

#output
#print('\n'.join(' '.join(str(x) for x in row) for row in output))

link_x = []
link_y = []
for i in range(0,m):
  for j in range(0,n):
    if(output[i,j] == 1):
      link_x.append(20*(36/m)*i)
      link_y.append(29.2*(25/n)*j)

#plt.imshow(map2)

fig, ax = plt.subplots(1, 1, figsize = (20, 20),dpi = 70)
ax.set_xticks(x_points)
ax.set_yticks(y_points)
ax.imshow(map2)
# ax.grid(color='b', linestyle='-', linewidth=2)
ax.imshow(map2)
ax.scatter(link_y, link_x, s=500, marker = "s")
ax.scatter(10,5,marker = '*')

f.Params.LogToConsole = 0
for b in range(70,111,1):
  h_factor = np.std(elevation)/b
  # objective function
  sumT = 0
  #sumT_2 = 0
  for i in range(0,m):
    for j in range(0,n):
      #sumT = sumT + a*x[i][j]*population[i,j]*(1/drought[i,j])*(1/elevation[i,j])
      #sumT = sumT + a*x[i][j]*population[i,j]*(1/drought[i,j])
      #sumT_2 = sumT_2 + a*population[i,j]*x[i][j]
      sumT = sumT + (cost_matrix[i][j] - elevation[i][j]/h_factor)*x[i][j]

  #sumT = 40*sumT - sumX*25

  f.setObjective(sumT, GRB.MAXIMIZE)
  f.optimize()
  print(sumX.getValue())
  link_x = []
  link_y = []
  for i in range(0,m):
    for j in range(0,n):
      output[i,j] = x[i][j].x

  for i in range(0,m):
    for j in range(0,n):
      if(output[i,j] == 1):
        link_x.append(20*i)
        link_y.append(29.2*j)

  #plt.imshow(map2)

  fig, ax = plt.subplots(1, 1, figsize = (20, 20),dpi = 70)
  ax.set_xticks(x_points)
  ax.set_yticks(y_points)
  ax.imshow(map2)
  # ax.grid(color='b', linestyle='-', linewidth=2)
  ax.imshow(map2)
  ax.scatter(link_y, link_x, s=500, marker = "s")
  plt.show()